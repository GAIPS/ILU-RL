"""This module acts as a wrapper for networks generated from network data"""

import operator as op
from itertools import groupby
from copy import deepcopy
from collections import defaultdict

from ilurl.flow.params import InitialConfig, TrafficLightParams
from ilurl.flow.params import (VehicleParams, SumoCarFollowingParams,
                            SumoLaneChangeParams)
from ilurl.flow.params import NetParams

from ilurl.utils.properties import lazy_property
from ilurl.params import InFlows

# TODO: Eliminate SUMO network parameters
from ilurl.loaders.nets import (get_routes, get_edges, get_nodes,
                                get_path, get_logic, get_connections,
                                get_types, get_tls_custom)


"""Contains the base network class."""

from ilurl.flow.params import InitialConfig
from ilurl.flow.params import TrafficLightParams
from ilurl.flow.params import SumoCarFollowingParams
from ilurl.flow.params import SumoLaneChangeParams
import time
# import xml.etree.ElementTree as ElementTree
# from lxml import etree
from collections import defaultdict

# default sumo probability value  TODO (ak): remove
DEFAULT_PROBABILITY = 0
# default sumo vehicle length value (in meters) TODO (ak): remove
DEFAULT_LENGTH = 5
# default sumo vehicle class class TODO (ak): remove
DEFAULT_VCLASS = 0


class Network(object):
    """Base network class.

    Initializes a new network. Networks are used to specify features of
    a network, including the positions of nodes, properties of the edges
    and junctions connecting these nodes, properties of vehicles and
    traffic lights, and other features as well. These features can later be
    acquired  from this class via a plethora of get methods (see
    documentation).

    This class uses network specific features to generate the necessary network
    configuration files needed to initialize a simulation instance. The methods
    of this class are called by the base network class.

    The network files can be created in one of three ways:

    * Custom networks can be generated by defining the properties of the
      network's directed graph. This is done by defining the nodes and edges
      properties using the ``specify_nodes`` and ``specify_edges`` methods,
      respectively, as well as other properties via methods including
      ``specify_types``, ``specify_connections``, etc... For more on this,
      see the tutorial on creating custom networks or refer to some of the
      available networks.

    * Network data can be collected from an OpenStreetMap (.osm) file. The
      .osm file is specified in the NetParams object. For example:

        >>> from ilurl.flow.params import NetParams
        >>> net_params = NetParams(osm_path='/path/to/osm_file.osm')

      In this case, no ``specify_nodes`` and ``specify_edges`` methods are
      needed. However, a ``specify_routes`` method is still needed to specify
      the appropriate routes vehicles can traverse in the network.

    * Network data can be collected from an sumo-specific network (.net.xml)
      file. This file is specified in the NetParams object. For example:

        >>> from ilurl.flow.params import NetParams
        >>> net_params = NetParams(template='/path/to/template')

      In this case, no ``specify_nodes`` and ``specify_edges`` methods are
      needed. However, a ``specify_routes`` method is still needed to specify
      the appropriate routes vehicles can traverse in the network.

    This class can be instantiated once and reused in multiple experiments.
    Note that this function stores all the relevant parameters. The
    generate() function still needs to be called separately.

    Attributes
    ----------
    orig_name : str
        the variable provided under the `name` parameter to this object upon
        instantiation
    name : str
        the variable provided under the `name` parameter to this object upon
        instantiation, appended with a timestamp variable. This timestamp is
        meant to differentiate generated network files during parallelism
    vehicles : ilurl.flow.params.VehicleParams
        vehicle specific parameters, used to specify the types and number of
        vehicles at the start of a simulation
    net_params : ilurl.flow.params.NetParams
        network specific parameters, used primarily to identify properties of a
        network such as the lengths of edges and the number of lanes in each
        edge. This attribute is very network-specific, and should contain the
        variables denoted by the `ADDITIONAL_NET_PARAMS` dict in each network
        class file
    initial_config : ilurl.flow.params.InitialConfig
        specifies parameters that affect the positioning of vehicle in the
        network at the start of a simulation. For more, see flow/core/params.py
    traffic_lights : ilurl.flow.params.TrafficLightParams
        used to describe the positions and types of traffic lights in the
        network. For more, see flow/core/params.py
    nodes : list of dict or None
        list of nodes that are assigned to the network via the `specify_nodes`
        method. All nodes in this variable are expected to have the following
        properties:

        * **name**: a unique identifier for the node
        * **x**: x-coordinate of the node, in meters
        * **y**: y-coordinate of the node, in meters

        If the network is meant to generate the network from an OpenStreetMap
        or template file, this variable is set to None
    edges : list of dict or None
        edges that are assigned to the network via the `specify_edges` method.
        This include the shape, position, and properties of all edges in the
        network. These properties include the following mandatory properties:

        * **id**: name of the edge
        * **from**: name of the node the edge starts from
        * **to**: the name of the node the edges ends at
        * **length**: length of the edge

        In addition, either the following properties need to be specifically
        defined or a **type** variable property must be defined with equivalent
        attributes in `self.types`:

        * **numLanes**: the number of lanes on the edge
        * **speed**: the speed limit for vehicles on the edge

        Moreover, the following attributes may optionally be available:

        * **shape**: the positions of intermediary nodes used to define the
          shape of an edge. If no shape is specified, then the edge will appear
          as a straight line.

        Note that, if the network is meant to generate the network from an
        OpenStreetMap or template file, this variable is set to None
    types : list of dict or None
        A variable used to ease the definition of the properties of various
        edges. Each element in the list consists of a dict consisting of the
        following property:

        * **id**: name of the edge type. Edges in the `self.edges` attribute
          with a similar value under the "type" key will adopt the properties
          of other components of this list, such as "speed" and "numLanes".

        If the type variable is None, then no types are available within the
        network. Furthermore, a proper example of this variable being used can
        be found under `specify_types` in flow/networks/loop.py.

        Note that, if the network is meant to generate the network from an
        OpenStreetMap or template file, this variable is set to None
    connections : list of dict or None
        A variable used to describe how any specific node's incoming and
        outgoing edges/lane pairs are connected. If no connections are
        specified, sumo generates default connections.

        If the connections attribute is set to None, then the connections
        within the network will be specified by the simulator.

        Note that, if the network is meant to generate the network from an
        OpenStreetMap or template file, this variable is set to None
    routes : dict
        A variable whose keys are the starting edge of a specific route, and
        whose values are the list of edges a vehicle is meant to traverse
        starting from that edge. These are only applied at the start of a
        simulation; vehicles are allowed to reroute within the environment
        immediately afterwards.
    edge_starts : list of (str, float)
        a list of tuples in which the first element of the tuple is the name of
        the edge/intersection/internal_link, and the second value is the
        distance of the link from some global reference, i.e. [(link_0, pos_0),
        (link_1, pos_1), ...]
    internal_edge_starts : list of (str, float)
        A variable similar to `edge_starts` but for junctions within the
        network. If no junctions are available, this variable will return the
        default variable: `[(':', -1)]` needed by sumo simulations.
    intersection_edge_starts : list of (str, float)
        A variable similar to `edge_starts` but for intersections within
        the network. This variable will be deprecated in future releases.

    Example
    -------
    The following examples are derived from the `RingNetwork` Network class
    located in flow/networks/ring.py, and should serve as an example of the
    types of outputs to be expected from the different variables of a network
    class.

    First of all, the ring road network class can be instantiated by running
    the following commands (note if this this unclear please refer to Tutorial
    1):

    >>> from ilurl.flow.networks import RingNetwork
    >>> from ilurl.flow.params import NetParams, VehicleParams
    >>>
    >>> network = RingNetwork(
    >>>     name='test',
    >>>     vehicles=VehicleParams(),
    >>>     net_params=NetParams(
    >>>         additional_params={
    >>>             'length': 230,
    >>>             'lanes': 1,
    >>>             'speed_limit': 30,
    >>>             'resolution': 40,
    >>>         }
    >>>     )
    >>> )

    The various attributes then look as follows:

    >>> print(network.nodes)
    >>> [{'id': 'bottom', 'x': '0', 'y': '-36.60563691113593'},
    >>>  {'id': 'right', 'x': '36.60563691113593', 'y': '0'},
    >>>  {'id': 'top', 'x': '0', 'y': '36.60563691113593'},
    >>>  {'id': 'left', 'x': '-36.60563691113593', 'y': '0'}]


    >>> print(network.edges)
    >>> [
    >>>     {'id': 'bottom',
    >>>      'type': 'edgeType',
    >>>      'from': 'bottom',
    >>>      'to': 'right',
    >>>      'length': '57.5',
    >>>      'shape': '0.00,-36.61 1.47,-36.58 2.95,-36.49 4.41,-36.34 '
    >>>               '5.87,-36.13 7.32,-35.87 8.76,-35.54 10.18,-35.16 '
    >>>               '11.59,-34.72 12.98,-34.23 14.35,-33.68 15.69,-33.07 '
    >>>               '17.01,-32.41 18.30,-31.70 19.56,-30.94 20.79,-30.13 '
    >>>               '21.99,-29.26 23.15,-28.35 24.27,-27.40 25.36,-26.40 '
    >>>               '26.40,-25.36 27.40,-24.27 28.35,-23.15 29.26,-21.99 '
    >>>               '30.13,-20.79 30.94,-19.56 31.70,-18.30 32.41,-17.01 '
    >>>               '33.07,-15.69 33.68,-14.35 34.23,-12.98 34.72,-11.59 '
    >>>               '35.16,-10.18 35.54,-8.76 35.87,-7.32 36.13,-5.87 '
    >>>               '36.34,-4.41 36.49,-2.95 36.58,-1.47 36.61,0.00'
    >>>     },
    >>>     {'id': 'right',
    >>>      'type': 'edgeType',
    >>>      'from': 'right',
    >>>      'to': 'top',
    >>>      'length': '57.5',
    >>>      'shape': '36.61,0.00 36.58,1.47 36.49,2.95 36.34,4.41 36.13,5.87 '
    >>>               '35.87,7.32 35.54,8.76 35.16,10.18 34.72,11.59 '
    >>>               '34.23,12.98 33.68,14.35 33.07,15.69 32.41,17.01 '
    >>>               '31.70,18.30 30.94,19.56 30.13,20.79 29.26,21.99 '
    >>>               '28.35,23.15 27.40,24.27 26.40,25.36 25.36,26.40 '
    >>>               '24.27,27.40 23.15,28.35 21.99,29.26 20.79,30.13 '
    >>>               '19.56,30.94 18.30,31.70 17.01,32.41 15.69,33.07 '
    >>>               '14.35,33.68 12.98,34.23 11.59,34.72 10.18,35.16 '
    >>>               '8.76,35.54 7.32,35.87 5.87,36.13 4.41,36.34 2.95,36.49 '
    >>>               '1.47,36.58 0.00,36.61'
    >>>     },
    >>>     {'id': 'top',
    >>>      'type': 'edgeType',
    >>>      'from': 'top',
    >>>      'to': 'left',
    >>>      'length': '57.5',
    >>>      'shape': '0.00,36.61 -1.47,36.58 -2.95,36.49 -4.41,36.34 '
    >>>               '-5.87,36.13 -7.32,35.87 -8.76,35.54 -10.18,35.16 '
    >>>               '-11.59,34.72 -12.98,34.23 -14.35,33.68 -15.69,33.07 '
    >>>               '-17.01,32.41 -18.30,31.70 -19.56,30.94 -20.79,30.13 '
    >>>               '-21.99,29.26 -23.15,28.35 -24.27,27.40 -25.36,26.40 '
    >>>               '-26.40,25.36 -27.40,24.27 -28.35,23.15 -29.26,21.99 '
    >>>               '-30.13,20.79 -30.94,19.56 -31.70,18.30 -32.41,17.01 '
    >>>               '-33.07,15.69 -33.68,14.35 -34.23,12.98 -34.72,11.59 '
    >>>               '-35.16,10.18 -35.54,8.76 -35.87,7.32 -36.13,5.87 '
    >>>               '-36.34,4.41 -36.49,2.95 -36.58,1.47 -36.61,0.00'
    >>>     },
    >>>     {'id': 'left',
    >>>      'type': 'edgeType',
    >>>      'from': 'left',
    >>>      'to': 'bottom',
    >>>      'length': '57.5',
    >>>      'shape': '-36.61,0.00 -36.58,-1.47 -36.49,-2.95 -36.34,-4.41 '
    >>>               '-36.13,-5.87 -35.87,-7.32 -35.54,-8.76 -35.16,-10.18 '
    >>>               '-34.72,-11.59 -34.23,-12.98 -33.68,-14.35 '
    >>>               '-33.07,-15.69 -32.41,-17.01 -31.70,-18.30 '
    >>>               '-30.94,-19.56 -30.13,-20.79 -29.26,-21.99 '
    >>>               '-28.35,-23.15 -27.40,-24.27 -26.40,-25.36 '
    >>>               '-25.36,-26.40 -24.27,-27.40 -23.15,-28.35 '
    >>>               '-21.99,-29.26 -20.79,-30.13 -19.56,-30.94 '
    >>>               '-18.30,-31.70 -17.01,-32.41 -15.69,-33.07 '
    >>>               '-14.35,-33.68 -12.98,-34.23 -11.59,-34.72 '
    >>>               '-10.18,-35.16 -8.76,-35.54 -7.32,-35.87 -5.87,-36.13 '
    >>>               '-4.41,-36.34 -2.95,-36.49 -1.47,-36.58 -0.00,-36.61'
    >>>     }
    >>> ]


    >>> print(network.types)
    >>> [{'id': 'edgeType', 'numLanes': '1', 'speed': '30'}]

    >>> print(network.connections)
    >>> None

    >>> print(network.routes)
    >>> {
    >>>     'top': ['top', 'left', 'bottom', 'right'],
    >>>     'left': ['left', 'bottom', 'right', 'top'],
    >>>     'bottom': ['bottom', 'right', 'top', 'left'],
    >>>     'right': ['right', 'top', 'left', 'bottom']
    >>> }


    >>> print(network.edge_starts)
    >>> [('bottom', 0), ('right', 57.5), ('top', 115.0), ('left', 172.5)]

    Finally, the ring network does not contain any junctions or intersections,
    and as a result the `internal_edge_starts` and `intersection_edge_starts`
    attributes are both set to None. For an example of a network with junctions
    and intersections, please refer to: flow/networks/figure_eight.py.

    >>> print(network.internal_edge_starts)
    >>> [(':', -1)]

    >>> print(network.intersection_edge_starts)
    >>> []
    """

    def __init__(self,
                 name,
                 vehicles,
                 net_params,
                 initial_config=InitialConfig(),
                 traffic_lights=TrafficLightParams()):
        """Instantiate the base network class.

        Attributes
        ----------
        name : str
            A tag associated with the network
        vehicles : ilurl.flow.params.VehicleParams
            see flow/core/params.py
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py
        initial_config : ilurl.flow.params.InitialConfig
            see flow/core/params.py
        traffic_lights : ilurl.flow.params.TrafficLightParams
            see flow/core/params.py
        """
        self.orig_name = name  # To avoid repeated concatenation upon reset
        self.name = name + time.strftime('_%Y%m%d-%H%M%S') + str(time.time())

        self.vehicles = vehicles
        self.net_params = net_params
        self.initial_config = initial_config
        self.traffic_lights = traffic_lights

        # specify routes vehicles can take
        self.routes = self.specify_routes(net_params)

        if net_params.template is None and net_params.osm_path is None:
            # specify the attributes of the nodes
            self.nodes = self.specify_nodes(net_params)
            # collect the attributes of each edge
            self.edges = self.specify_edges(net_params)
            # specify the types attributes (default is None)
            self.types = self.specify_types(net_params)
            # specify the connection attributes (default is None)
            self.connections = self.specify_connections(net_params)

        # this is to be used if file paths other than the the network geometry
        # file is specified
        elif type(net_params.template) is dict:
            if 'rou' in net_params.template:
                veh, rou = self._vehicle_infos(net_params.template['rou'])

                vtypes = self._vehicle_type(net_params.template.get('vtype'))
                cf = self._get_cf_params(vtypes)
                lc = self._get_lc_params(vtypes)

                # add the vehicle types to the VehicleParams object
                for t in vtypes:
                    vehicles.add(veh_id=t, car_following_params=cf[t],
                                 lane_change_params=lc[t], num_vehicles=0)

                # add the routes of the vehicles that will be departed later
                # under the name of the vehicle. This will later be identified
                # by k.vehicles._add_departed
                self.routes = rou

                # vehicles to be added with different departure times
                self.template_vehicles = veh

            self.types = None
            self.nodes = None
            self.edges = None
            self.connections = None

        # osm_path or template as type str
        else:
            self.nodes = None
            self.edges = None
            self.types = None
            self.connections = None

        # optional parameters, used to get positions from some global reference
        self.edge_starts = self.specify_edge_starts()
        self.internal_edge_starts = self.specify_internal_edge_starts()
        self.intersection_edge_starts = []  # this will be deprecated

    # TODO: convert to property
    def specify_edge_starts(self):
        """Define edge starts for road sections in the network.

        This is meant to provide some global reference frame for the road
        edges in the network.

        By default, the edge starts are specified from the network
        configuration file. Note that, the values are arbitrary but do not
        allow the positions of any two edges to overlap, thereby making them
        compatible with all starting position methods for vehicles.

        Returns
        -------
        list of (str, float)
            list of edge names and starting positions,
            ex: [(edge0, pos0), (edge1, pos1), ...]
        """
        return None

    # TODO: convert to property
    def specify_internal_edge_starts(self):
        """Define the edge starts for internal edge nodes.

        This is meant to provide some global reference frame for the internal
        edges in the network.

        These edges are the result of finite-length connections between road
        sections. This methods does not need to be specified if "no-internal-
        links" is set to True in net_params.

        By default, all internal edge starts are given a position of -1. This
        may be overridden; however, in general we do not worry about internal
        edges and junctions in large networks.

        Returns
        -------
        list of (str, float)
            list of internal junction names and starting positions,
            ex: [(internal0, pos0), (internal1, pos1), ...]
        """
        return [(':', -1)]

    # TODO: convert to property
    def specify_nodes(self, net_params):
        """Specify the attributes of nodes in the network.

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py

        Returns
        -------
        list of dict

            A list of node attributes (a separate dict for each node). Nodes
            attributes must include:

            * id {string} -- name of the node
            * x {float} -- x coordinate of the node
            * y {float} -- y coordinate of the node

        Other attributes may also be specified. See:
        http://sumo.dlr.de/wiki/Networks/Building_Networks_from_own_XML-descriptions#Node_Descriptions
        """
        raise NotImplementedError

    # TODO: convert to property
    def specify_edges(self, net_params):
        """Specify the attributes of edges connecting pairs on nodes.

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py

        Returns
        -------
        list of dict

            A list of edges attributes (a separate dict for each edge). Edge
            attributes must include:

            * id {string} -- name of the edge
            * from {string} -- name of node the directed edge starts from
            * to {string} -- name of the node the directed edge ends at

            In addition, the attributes must contain at least one of the
            following:

            * "numLanes" {int} and "speed" {float} -- the number of lanes and
              speed limit of the edge, respectively
            * type {string} -- a type identifier for the edge, which can be
              used if several edges are supposed to possess the same number of
              lanes, speed limits, etc...

        Other attributes may also be specified. See:
        http://sumo.dlr.de/wiki/Networks/Building_Networks_from_own_XML-descriptions#Edge_Descriptions
        """
        raise NotImplementedError

    # TODO: convert to property
    def specify_types(self, net_params):
        """Specify the attributes of various edge types (if any exist).

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py

        Returns
        -------
        list of dict
            A list of type attributes for specific groups of edges. If none are
            specified, no .typ.xml file is created.

        For information on type attributes, see:
        http://sumo.dlr.de/wiki/Networks/Building_Networks_from_own_XML-descriptions#Type_Descriptions
        """
        return None

    # TODO: convert to property
    def specify_connections(self, net_params):
        """Specify the attributes of connections.

        These attributes are used to describe how any specific node's incoming
        and outgoing edges/lane pairs are connected. If no connections are
        specified, sumo generates default connections.

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py

        Returns
        -------
        list of dict
            A list of connection attributes. If none are specified, no .con.xml
            file is created.

        For information on type attributes, see:
        http://sumo.dlr.de/wiki/Networks/Building_Networks_from_own_XML-descriptions#Connection_Descriptions
        """
        return None

    # TODO: convert to property
    def specify_routes(self, net_params):
        """Specify the routes vehicles can take starting from any edge.

        Routes can be specified in one of three ways:

        * In this case of deterministic routes (as is the case in the ring road
          network), the routes can be specified as dictionary where the key
          element represents the starting edge and the element is a single list
          of edges the vehicle must traverse, with the first edge corresponding
          to the edge the vehicle begins on. Note that the edges must be
          connected for the route to be valid.

          For example (from ilurl.flow/networks/ring.py):

          >>> def specify_routes(self, net_params):
          >>>     return {
          >>>         "top": ["top", "left", "bottom", "right"],
          >>>         "left": ["left", "bottom", "right", "top"],
          >>>         "bottom": ["bottom", "right", "top", "left"],
          >>>         "right": ["right", "top", "left", "bottom"]
          >>>     }

        * Alternatively, if the routes are meant to be stochastic, each element
          can consist of a list of (route, probability) tuples, where the first
          element in the tuple is one of the routes a vehicle can take from a
          specific starting edge, and the second element is the probability
          that vehicles will choose that route. Note that, in this case, the
          sum of probability values for each dictionary key must sum up to one.

          For example, if we were to imagine the edge "right" in the ring road
          examples where split into two edges, "right_0" and "right_1", the
          routes for vehicles in this network in the probabilistic setting can
          be:

          >>> def specify_routes(self, net_params):
          >>>     return {
          >>>         "top": [
          >>>             (["top", "left", "bottom", "right_0"], 0.9),
          >>>             (["top", "left", "bottom", "right_1"], 0.1)
          >>>         ],
          >>>         "left": [
          >>>             (["left", "bottom", "right_0", "top"], 0.3),
          >>>             (["left", "bottom", "right_1", "top"], 0.7)
          >>>         ],
          >>>         "bottom": [
          >>>             (["bottom", "right_0", "top", "left"], 0.5),
          >>>             (["bottom", "right_1", "top", "left"], 0.5)
          >>>         ],
          >>>         "right_0": [
          >>>             (["right_0", "top", "left", "bottom"], 1)
          >>>         ],
          >>>         "right_1": [
          >>>             (["right_1", "top", "left", "bottom"], 1)
          >>>         ]
          >>>     }

        * Finally, if you would like to assign a specific starting edge and
          route to a vehicle with a specific ID, you can do so by adding a
          element into the dictionary whose key is the name of the vehicle and
          whose content is the list of edges the vehicle is meant to traverse
          as soon as it is introduced to the network.

          As an example, assume we have 4 vehicles named 'human_0', 'human_1',
          'human_2', and 'human_3' in the original ring road. Then, an
          appropriate definition of the routes may look something like:

          >>> def specify_routes(self, net_params):
          >>>     return {
          >>>         "human_0": ["top", "left", "bottom", "right"],
          >>>         "human_1": ["left", "bottom", "right", "top"],
          >>>         "human_2": ["bottom", "right", "top", "left"],
          >>>         "human_3": ["right", "top", "left", "bottom"]
          >>>     }

          **Note**: This feature is experimental, and may not always work as
          expected (for example if the starting positions and routes of a
          specific vehicle do not match).

        The `define_routes` method is optional, and need not be defined. If it
        is not implemented, vehicles that enter a network are assigned routes
        consisting solely on their current edges, and exit the network once
        they reach the end of their edge. Routes, however, can be reassigned
        during simulation via a routing controller (see
        flow/controllers/routing_controllers.py).

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py

        Returns
        -------
        dict
            Key = name of the starting edge
            Element = list of edges a vehicle starting from this edge must
            traverse *OR* a list of (route, probability) tuples for each
            starting edge
        """
        return None

    @staticmethod
    def gen_custom_start_pos(cls, net_params, initial_config, num_vehicles):
        """Generate a user defined set of starting positions.

        Parameters
        ----------
        cls : flow.kernel.network.BaseKernelNetwork
            flow network kernel, with all the relevant methods implemented
        net_params : ilurl.flow.params.NetParams
            network-specific parameters
        initial_config : ilurl.flow.params.InitialConfig
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network

        Returns
        -------
        list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        list of int
            list of start lanes
        list of float
            list of start speeds
        """
        raise NotImplementedError

    @staticmethod
    def _vehicle_infos(file_names):
        """Import of vehicle from a configuration file.

        This is a utility function for computing vehicle information. It
        imports a network configuration file, and returns the information on
        the vehicle and add it into the Vehicle object.

        Parameters
        ----------
        file_names : list of str
            path to the xml file to load

        Returns
        -------
        dict <dict>

            * Key = id of the vehicle
            * Element = dict of departure speed, vehicle type, depart Position,
              depart edges
        """
        # this is meant to deal with the case that there is only one rou file
        if isinstance(file_names, str):
            file_names = [file_names]

        vehicle_data = dict()
        routes_data = dict()
        type_data = defaultdict(int)

        for filename in file_names:
            # import the .net.xml file containing all edge/type data
            parser = etree.XMLParser(recover=True)
            tree = ElementTree.parse(filename, parser=parser)
            root = tree.getroot()

            # collect the departure properties and routes and vehicles whose
            # properties are instantiated within the .rou.xml file. This will
            # only apply if such data is within the file (it is not implemented
            # by networks in Flow).
            for vehicle in root.findall('vehicle'):
                # collect the edges the vehicle is meant to traverse
                route = vehicle.find('route')
                route_edges = route.attrib["edges"].split(' ')

                # collect the names of each vehicle type and number of vehicles
                # of each type
                type_vehicle = vehicle.attrib['type']
                type_data[type_vehicle] += 1

                vehicle_data[vehicle.attrib['id']] = {
                    'departSpeed': vehicle.attrib['departSpeed'],
                    'depart': vehicle.attrib['depart'],
                    'typeID': type_vehicle,
                    'departPos': vehicle.attrib['departPos'],
                }

                routes_data[vehicle.attrib['id']] = route_edges

            # collect the edges the vehicle is meant to traverse for the given
            # sets of routes that are not associated with individual vehicles
            for route in root.findall('route'):
                route_edges = route.attrib["edges"].split(' ')
                routes_data[route.attrib['id']] = route_edges

        return vehicle_data, routes_data

    @staticmethod
    def _vehicle_type(filename):
        """Import vehicle type data from a *.add.xml file.

        This is a utility function for outputting all the type of vehicle.

        Parameters
        ----------
        filename : str
            path to the vtypes.add.xml file to load

        Returns
        -------
        dict or None
            the key is the vehicle_type id and the value is a dict we've type
            of the vehicle, depart edges, depart Speed, departPos. If no
            filename is provided, this method returns None as well.
        """
        if filename is None:
            return None

        parser = etree.XMLParser(recover=True)
        tree = ElementTree.parse(filename, parser=parser)

        root = tree.getroot()
        veh_type = {}

        # this hack is meant to support the LuST network and Flow networks
        root = [root] if len(root.findall('vTypeDistribution')) == 0 \
            else root.findall('vTypeDistribution')

        for r in root:
            for vtype in r.findall('vType'):
                # TODO: make for everything
                veh_type[vtype.attrib['id']] = {
                    'vClass': vtype.attrib.get('vClass', DEFAULT_VCLASS),
                    'accel': vtype.attrib['accel'],
                    'decel': vtype.attrib['decel'],
                    'sigma': vtype.attrib['sigma'],
                    'length': vtype.attrib.get('length', DEFAULT_LENGTH),
                    'minGap': vtype.attrib['minGap'],
                    'maxSpeed': vtype.attrib['maxSpeed'],
                    'probability': vtype.attrib.get(
                        'probability', DEFAULT_PROBABILITY),
                    'speedDev': vtype.attrib['speedDev']
                }

        return veh_type

    @staticmethod
    def _get_cf_params(vtypes):
        """Return the car-following sumo params from vtypes."""
        ret = {}
        for typ in vtypes:
            # TODO: add vClass
            ret[typ] = SumoCarFollowingParams(
                speed_mode='all_checks',
                accel=float(vtypes[typ]['accel']),
                decel=float(vtypes[typ]['decel']),
                sigma=float(vtypes[typ]['sigma']),
                length=float(vtypes[typ]['length']),
                min_gap=float(vtypes[typ]['minGap']),
                max_speed=float(vtypes[typ]['maxSpeed']),
                probability=float(vtypes[typ]['probability']),
                speed_dev=float(vtypes[typ]['speedDev'])
            )

        return ret

    @staticmethod
    def _get_lc_params(vtypes):
        """Return the lane change sumo params from vtypes."""
        ret = {}
        for typ in vtypes:
            ret[typ] = SumoLaneChangeParams(lane_change_mode=1621)

        return ret

    def __str__(self):
        """Return the name of the network and the number of vehicles."""
        return 'Network ' + self.name + ' with ' + \
               str(self.vehicles.num_vehicles) + ' vehicles.'

class CityflowNetwork(Network):
    """This class leverages on specs created by SUMO."""

    def __init__(self,
                 network_id,
                 horizon=360,
                 net_params=None,
                 vehicles=None,
                 demand_type='constant',
                 demand_mode='step',
                 initial_config=None,
                 tls_type='rl'):

        """Builds a new network from inflows -- the resulting
        vehicle trips will be stochastic use it for training"""
        self.network_id = network_id
        baseline = (tls_type == 'actuated')
        self.cycle_time, self.programs = get_tls_custom(
                                network_id, baseline=baseline)

        if initial_config is None:
            initial_config = InitialConfig(
                edges_distribution=tuple(get_routes(network_id).keys())
            )

        if net_params is None:
            #TODO: check vtype
            if vehicles is None:
                vehicles = VehicleParams()
                vehicles.add(
                    veh_id="human",
                    car_following_params=SumoCarFollowingParams(
                        min_gap=2.5,
                        decel=7.5,  # Avoid collisions at emergency stops.
                    ),
                    lane_change_params=SumoLaneChangeParams(
                        lane_change_mode='strategic'
                    )
                )

            inflows = InFlows(network_id, horizon, demand_type,
                              demand_mode=demand_mode, initial_config=initial_config)

            net_params = NetParams(inflows,
                                   template=get_path(network_id, 'net'))

        # static program (required for rl)
        tls_logic = TrafficLightParams(baseline=False)
        if tls_type not in ('actuated', ):
            programs = get_logic(network_id)
            if programs:
                for prog in programs:
                    node_id = prog.pop('id')
                    prog['tls_type'] = prog.pop('type')
                    prog['programID'] = int(prog.pop('programID')) + 1
                    tls_logic.add(node_id, **prog)
        else:
            for tls_id, tls_args in self.programs.items():
                tls_logic.add(tls_id, **tls_args)

        super(CityflowNetwork, self).__init__(
                 network_id,
                 vehicles,
                 net_params,
                 initial_config=initial_config,
                 traffic_lights=tls_logic
        )

        self.nodes = self.specify_nodes(net_params)
        self.edges = self.specify_edges(net_params)
        self.connections = self.specify_connections(net_params)
        self.types = self.specify_types(net_params)


    def specify_nodes(self, net_params):
        return get_nodes(self.network_id)


    def specify_edges(self, net_params):
        return get_edges(self.network_id)


    def specify_connections(self, net_params):
        """Connections bind edges' lanes to one another at junctions

            DEF:
            ----
            definitions follow the standard
            *Name   :Type
                Description

            *from   :edge id (string)
                The ID of the incoming edge at which the connection
                begins
            *to     :edge id (string)
                The ID of the outgoing edge at which the connection ends
            *fromLane   :index (unsigned int)
                The lane of the incoming edge at which the connection
                begins
            *toLane     :index (unsigned int)
                The lane of the outgoing edge at which the connection ends
            *via    :lane id (string)
                The id of the lane to use to pass this connection across the junction
            *tl     :traffic light id (string
                The id of the traffic light that controls this connection; the attribute is missing if the connection is not controlled by a traffic light
            *linkIndex  :index (unsigned int
                The index of the signal responsible for the connection within the traffic light; the attribute is missing if the connection is not controlled by a traffic light
            *dir:enum
                ("s" = straight, "t" = turn, "l" = left, "r" = right, "L" = partially left, R = partially right, "invalid" = no direction
            The direction of the connection
            *state:enum
                ("-" = dead end, "=" = equal, "m" = minor link, "M" = major link, traffic light only: "O" = controller off, "o" = yellow flashing, "y" = yellow minor link, "Y" = yellow major link, "r" = red, "g" = green minor, "G" green major
            The state of the connection

            REF:
            ----
            http://sumo.sourceforge.net/userdoc/Networks/SUMO_Road_Networks.html
        """
        return get_connections(self.network_id)


    def specify_routes(self, net_params):
        return get_routes(self.network_id)

    def specify_types(self, net_params):
        return get_types(self.network_id)

    def specify_edge_starts(self):
        "see parent class"
        ret = [(e['id'], max([float(ln['length']) for ln in e['lanes']]))
                for e in get_edges(self.network_id)]
        return ret

    @lazy_property
    def links(self):
        """Dict version from connections"""
        conns = deepcopy(self.connections)
        return {conn.pop('via'): conn for conn in conns if 'via' in conn}

    @lazy_property
    def tls_phases(self):
        """Returns a nodeid x sets of non conflicting movement patterns.
            The sets are index by integers and the moviment patterns are
            expressed as lists of approaches. We consider only incoming
            approaches to be controlled by phases.

        Returns:
        ------
        * phases: dict<string,dict<int, dict<string, obj>>>
            keys: nodeid, phase_id, 'states', 'components'

        Usage:
        -----
        > network.tls_states
        > {'gneJ2':
            ['GGGgrrrrGGGgrrrr', 'yyygrrrryyygrrrr', 'rrrGrrrrrrrGrrrr',
            'rrryrrrrrrryrrrr', 'rrrrGGGgrrrrGGGg', 'rrrryyygrrrryyyg',
            'rrrrrrrGrrrrrrrG', 'rrrrrrryrrrrrrry']}

        > network.tls_phases
        > {'gneJ2':
            {0: {'incoming':
                    [('-gneE8', [0, 1, 2]), ('gneE12', [0, 1, 2])],
                    'states': ['GGGgrrrrGGGgrrrr']
                },
             1: {'incoming':
                     [('-gneE8', [2]), ('gneE12', [2])],
                  'states': ['yyygrrrryyygrrrr', 'rrrGrrrrrrrGrrrr',
                             'rrryrrrrrrryrrrr']
                },
             2: {'incoming':
                     [('gneE7', [0, 1, 2]), ('-gneE10', [0, 1, 2])],
                 'states': ['rrrrGGGgrrrrGGGg']
                 },
             3: {'incoming':
                     [('gneE7', [2]), ('-gneE10', [2])],
                 'states': ['rrrryyygrrrryyyg', 'rrrrrrrGrrrrrrrG',
                            'rrrrrrryrrrrrrry']
                }
             }
           }

        DEF:
        ---
        A phase is a combination of movement signals which are
        non-conflicting. The relation from states to phases is
        such that phases "disregards" yellow configurations
        usually num_phases = num_states / 2

        REF:
        ---
        Wei et al., 2019
        http://arxiv.org/abs/1904.08117
        """

        ret = defaultdict(dict)
        def fn(x, n):
            return x.get('tl') == n and 'linkIndex' in x

        for nid in self.tls_ids:
            # green and yellow are considered to be one phase
            connections = [c for c in self.connections if fn(c, nid)]
            states = self.tls_states[nid]
            incoming_links = {
                int(cn['linkIndex']): (cn['from'], int(cn['fromLane']))
                for cn in connections if 'linkIndex' in cn
            }

            outgoing_links = {
                int(cn['linkIndex']): (cn['to'], int(cn['toLane']))
                for cn in connections if 'linkIndex' in cn
            }
            i = 0
            components = {}
            for state in states:
                incoming = self._group_links(incoming_links, state)
                outgoing = self._group_links(outgoing_links, state)

                # Match states
                # The state related to this phase might already have been added.
                found = False
                if any(incoming) or any(outgoing):
                    for j in range(0, i + 1):

                        if j in ret[nid]:
                            # same edge_id and lanes
                            found = ret[nid][j]['incoming'] == incoming and \
                                        ret[nid][j]['outgoing'] == outgoing

                            if found:
                                ret[nid][j]['states'].append(state)
                                break

                    if not found:
                        ret[nid][i] = {
                            'incoming': incoming,
                            'outgoing': outgoing,
                            'states': [state]
                        }
                        i += 1
                else:
                    # add to the last phase
                    # states only `r` and `y`
                    ret[nid][i - 1]['states'].append(state)
        return ret

    def _group_links(self, links, state):
        """Transforms links into components

        Parameters:
        ----------
        * links: dict<int, tuple<str, int>
              links: linkIndex --> (edge_id, lane)
              ex: {7: ('-309265400', 0), 8: ('-309265400', 0), ..., 6:('309265402', 1)}

        * state: str
           ex: 'rrrrrGGGGG'

        Returns:
        --------
            component: list<tuple<str,list<int>>>
                    component --> [(edge_a, [lane_0, lane_1]), ...]
                    ex: [('309265401', [0, 1]), ('-238059328', [0, 1])]
        """
        # components: (linkIndex, phase_num, edge_id, lane)
        # states are indexed by linkIndex
        # 'G', 'g' states are grouped together.
        components = {
            (lnk,) + edge_lane
            for lnk, edge_lane in links.items()
            if state[lnk] in ('G','g')
        }
        # adds components if they don't exist
        if components:
            # sort by link, edge_id
            components = \
                sorted(components, key=op.itemgetter(0, 1))

            # groups lanes by edge_ids and states
            components = \
                [(k, list({l[-1] for l in g}))
                 for k, g in groupby(components, key=op.itemgetter(1))]
        return components

    @lazy_property
    def tls_max_capacity(self):
        """Max speeds and counts that an intersection can handle

        Returns:
        -------
            * max_capacity: dict<string, dict<int, dict<int, tuple<float, int>>>
                keys: string tls_id keys: int phase_id keys: int lane
                tuple<float, int>: max. speeds (m/s), counts (vehs)

        Usage:
        > network.tls_max_capacity
        > {'gneJ0': {0: {0:(22.25, 40), 1: (7.96, 12)}, 1:{0:(8.33, 6)}}, ...

        """
        tlcap = {}
        for tls_id in self.tls_ids:
            phase_cap = {}
            for phase, data in self.tls_phases[tls_id].items():
                edge_cap = {}
                for edge_id, lane_ids in data['incoming']:
                    edge = [e for e in self.edges if e['id'] == edge_id][0]
                    for lane_id in lane_ids:
                        lane = [_lane for _lane in edge['lanes']
                                if _lane['index'] == repr(lane_id)][0]

                        ls, ll = float(lane['speed']), float(lane['length'])
                        edge_cap[lane_id] = (ls, int(ll / self.veh_length))
                    phase_cap[phase] = edge_cap
            tlcap[tls_id] = phase_cap
        return tlcap

    @lazy_property
    def tls_states(self):
        """states wrt to programID = 1 for traffic light nodes

        Returns:
        -------
            * states: dict<string, list<string>>

        Usage:
        ------
        > network.tls_states
        > {'247123161': ['GGrrrGGrrr', 'yyrrryyrrr', 'rrGGGrrGGG', 'rryyyrryyy']}O

        REF:
        ----
            http://sumo.sourceforge.net/userdoc/Simulation/Traffic_Lights.html
        """
        cfg = self.traffic_lights.get_properties()

        def fn(x):
            return x['type'] in ('static', 'actuated') and x['programID'] == 1

        return {
            tid: [p['state'] for p in cfg[tid]['phases'] if fn(cfg[tid])]
            for tid in self.tls_ids
        }

    @lazy_property
    def tls_durations(self):
        """Gives the times or durations in seconds for each of the states
        on the default programID = 1

        Returns:
        -------
            * durations: list<int>
                a list of integer representing the time in seconds, each
                state is alloted on the default static program.

        Usage:
        ------
        > network.tls_durations
        > {'247123161': [39, 6, 39, 6]}

        REF:
        ----
            http://sumo.sourceforge.net/userdoc/Simulation/Traffic_Lights.html
        """
        cfg = self.traffic_lights.get_properties()

        def fn(x):
            return x['type'] == 'static' and x['programID'] == 1

        return {
            t: [int(p['duration']) for p in cfg[t]['phases'] if fn(cfg[t])]
            for t in self.tls_ids
        }

    @lazy_property
    def tls_ids(self):
        """List of nodes which are also traffic light signals

        Returns
        -------
            * nodeids: list<string>

        Usage:
        -----
        # intersection
        > network.tls_ids
        > ['247123161']

        """
        return [n['id'] for n in self.nodes if n['type'] == 'traffic_light']

    @lazy_property
    def phases_per_tls(self):
        """Dict containing the number of phases per traffic light.

        Returns
        -------
            * phases_per_tls: dict

        """
        return {tid: len(self.tls_phases[tid]) for tid in self.tls_ids}

    @lazy_property
    def num_signal_plans_per_tls(self):
        """Dict containing the number of signal plans available
        at 'programs' per traffic light.

        Returns
        -------
            * num_signal_plans_per_tls: dict

        """
        return {tid: len(self.programs[tid]) for tid in self.tls_ids}

    @lazy_property
    def veh_length(self):
        """mean veh length

        Limitations:
        -----------
            * It considers an average number vehicles over all vehicle_types
            * If vehicle length is not provided converts it to length 5 default

        Sumo:
        -----
            length 	float 	5.0 	The vehicle's netto-length (length) (in m)
            min_gap 	float 	2.5 	Empty space after leader [m]
            max_speed 	float 	55.55 (200 km/h) for vehicles   The vehicle's maximum velocity (in m/s)

        Use case:
        --------
             Determine the theoretical flow:
             q (flow) [cars/h]  = D (density) [cars/km] x V (speed) [km/h]

        """
        xs = 0
        for i, veh_type in enumerate(self.vehicles.types):
            x = veh_type.get('min_gap', 2.5) + veh_type.get('length', 5.0)
            xs = (x + i * xs) / (i + 1)     # mean of lengths
        return xs
