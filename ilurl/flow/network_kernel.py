"""Script containing the base network kernel class."""

from collections import defaultdict
import os
from pathlib import Path
import logging
import random
import numpy as np
from copy import deepcopy

# length of vehicles in the network, in meters
VEHICLE_LENGTH = 5

ILURL_PATH = Path(os.environ['ILURL_HOME'])
NETWORKS_PATH = ILURL_PATH / 'data' / 'networks/'

class BaseKernelNetwork(object):
    """Base network kernel.

    This kernel subclass is responsible for generating any simulation-specific
    components needed to simulate a traffic network. This may include network
    creating configuration files that support the generating of certain traffic
    networks in a simulator (e.g. sumo), or may be as simple as passing network
    features from the network class (see flow/networks/base.py) and
    transferring them to the simulator kernel later on.

    In addition to generating files for network initialization, the network
    kernel performs two auxiliary tasks:

    * State acquisition: The network kernel contains several methods that can
      be used to acquire state information on the properties of the network
      that is being simulated, e.g. the number of lanes on an edge, the length
      of an edge, the available routes from a starting position, etc... If, for
      example, you would like to determine the maximum speed a vehicle can
      travel within the network, this can be done by calling the following
      command:

        >>> from ilurl.flow.envs.base import Env
        >>> env = Env(...)
        >>> max_speed = env.k.network.max_speed()

      All relevant methods may be found within the Flow documentation.

    * Methods for generating initial vehicle positions: Initial vehicle
      positions are generated by the abstract network kernel, and may be
      overridden by the network generated from a flow.networks.Network object
      if the spacing in ``initial_config`` is set to random. Default initial
      positions include uniform starting positions (where all vehicles are
      equally spacing) or random starting positions (limited by some min_gap).
      For more details on how to augment the starting position of vehicles,
      see:  # TODO: create tutorial
    """

    def __init__(self, master_kernel, sim_params):
        """Instantiate the base network kernel.

        Parameters
        ----------
        master_kernel : flow.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        sim_params : ilurl.flow.params.SimParams
            simulation-specific parameters
        """
        self.master_kernel = master_kernel
        self.sim_params = sim_params
        self.kernel_api = None

        # These variable need to be filled in by the generate_network method.
        self.network = None
        self.orig_name = None
        self.name = None
        self.edgestarts = None
        self.internal_edgestarts = None
        self.intersection_edgestarts = None
        self.internal_edgestarts_dict = None
        self.total_edgestarts = None
        self.total_edgestarts_dict = None

    def generate_network(self, network):
        """Generate the necessary prerequisites for the simulating a network.

        Parameters
        ----------
        network : flow.networks.Network
            an object containing relevant network-specific features such as the
            locations and properties of nodes and edges in the network
        """
        raise NotImplementedError

    def pass_api(self, kernel_api):
        """Acquire the kernel api that was generated by the simulation kernel.

        Parameters
        ----------
        kernel_api : any
            an API that may be used to interact with the simulator
        """
        self.kernel_api = kernel_api

    def update(self, reset):
        """Update the network with current state information.

        Since networks are generally static, this will most likely not include
        any actions being performed. This is primarily here for consistency
        with other sub-kernels.

        Parameters
        ----------
        reset : bool
            specifies whether the simulator was reset in the last simulation
            step
        """
        raise NotImplementedError

    def close(self):
        """Close the network."""
        raise NotImplementedError

    ###########################################################################
    #                        State acquisition methods                        #
    ###########################################################################

    def edge_length(self, edge_id):
        """Return the length of a given edge/junction.

        Return -1001 if edge not found.
        """
        raise NotImplementedError

    def length(self):
        """Return the total length of all junctions and edges."""
        raise NotImplementedError

    def speed_limit(self, edge_id):
        """Return the speed limit of a given edge/junction.

        Return -1001 if edge not found.
        """
        raise NotImplementedError

    def max_speed(self):
        """Return the maximum achievable speed on any edge in the network."""
        raise NotImplementedError

    def num_lanes(self, edge_id):
        """Return the number of lanes of a given edge/junction.

        Return -1001 if edge not found.
        """
        raise NotImplementedError

    def get_edge_list(self):
        """Return the names of all edges in the network."""
        raise NotImplementedError

    def get_junction_list(self):
        """Return the names of all junctions in the network."""
        raise NotImplementedError

    def get_edge(self, x):  # TODO: maybe remove
        """Compute an edge and relative position from an absolute position.

        Parameters
        ----------
        x : float
            absolute position in network

        Returns
        -------
        tup
            1st element: edge name (such as bottom, right, etc.)
            2nd element: relative position on edge
        """
        raise NotImplementedError

    def get_x(self, edge, position):  # TODO: maybe remove
        """Return the absolute position on the track.

        Parameters
        ----------
        edge : str
            name of the edge
        position : float
            relative position on the edge

        Returns
        -------
        float
            position with respect to some global reference
        """
        raise NotImplementedError

    def next_edge(self, edge, lane):
        """Return the next edge/lane pair from the given edge/lane.

        These edges may also be internal links (junctions). Returns an empty
        list if there are no edge/lane pairs in front.
        """
        raise NotImplementedError

    def prev_edge(self, edge, lane):
        """Return the edge/lane pair right before this edge/lane.

        These edges may also be internal links (junctions). Returns an empty
        list if there are no edge/lane pairs behind.
        """
        raise NotImplementedError

    ###########################################################################
    #            Methods for generating initial vehicle positions.            #
    ###########################################################################

    def generate_starting_positions(self, initial_config, num_vehicles=None):
        """Generate starting positions for vehicles in the network.

        Calls all other starting position generating classes.

        Parameters
        ----------
        initial_config : ilurl.flow.params.InitialConfig
            see flow/core/params.py
        num_vehicles : int, optional
            number of vehicles to be placed on the network. If no value is
            specified, the value is collected from the vehicles class

        Returns
        -------
        list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        list of int
            list of start lanes

        Raises
        ------
        
            if the spacing mode is not {'uniform', 'random', 'custom'}
        """
        num_vehicles = num_vehicles or self.network.vehicles.num_vehicles

        if initial_config.spacing == 'uniform':
            startpositions, startlanes = self.gen_even_start_pos(
                initial_config, num_vehicles)
        elif initial_config.spacing == 'random':
            startpositions, startlanes = self.gen_random_start_pos(
                initial_config, num_vehicles)
        elif initial_config.spacing == 'custom':
            startpositions, startlanes = self.gen_custom_start_pos(
                initial_config, num_vehicles)
        else:
            raise ValueError('"spacing" argument in initial_config does '
                                 'not contain a valid option')

        return startpositions, startlanes

    def gen_even_start_pos(self, initial_config, num_vehicles):
        """Generate uniformly spaced starting positions.

        If the perturbation term in initial_config is set to some positive
        value, then the start positions are perturbed from a uniformly spaced
        distribution by a gaussian whose std is equal to this perturbation
        term.

        Parameters
        ----------
        initial_config : ilurl.flow.params.InitialConfig
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network

        Returns
        -------
        list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        list of int
            list of start lanes
        """
        if isinstance(initial_config.edges_distribution, dict):
            # check that the number of vehicle in edges_distribution matches
            # that of the vehicles class
            num_vehicles_e = sum(initial_config.edges_distribution[k]
                                 for k in initial_config.edges_distribution)
            assert num_vehicles == num_vehicles_e, \
                'Number of vehicles in edges_distribution and the Vehicles ' \
                'class do not match: {}, {}'.format(num_vehicles,
                                                    num_vehicles_e)

            # add starting positions and lanes
            edges_distribution = deepcopy(initial_config.edges_distribution)
            startpositions, startlanes = [], []
            for key in edges_distribution:
                # set the edge distribution to only include the next edge
                initial_config.edges_distribution = [key]
                # set the number of vehicles that this edge can carry
                num_vehicles = edges_distribution[key]
                # recursively collect the next starting positions and lanes
                pos, lane = self.gen_even_start_pos(
                    initial_config, num_vehicles)
                startpositions.extend(pos)
                startlanes.extend(lane)
            return startpositions, startlanes

        (x0, min_gap, bunching, lanes_distr, available_length,
         available_edges, initial_config) = \
            self._get_start_pos_util(initial_config, num_vehicles)

        # return an empty list of starting positions and lanes if there are no
        # vehicles to be placed
        if num_vehicles == 0:
            return [], []

        increment = available_length / num_vehicles

        # when consecutive edges do not have the same number of lanes, vehicles
        # are not allowed to be in between edges (as a lane might not exist on
        # the other side)
        flag = False
        lanes = [self.num_lanes(edge) for edge in self.get_edge_list()]
        if any(lanes[0] != lanes[i] for i in range(1, len(lanes))):
            flag = True

        x = x0
        car_count = 0
        startpositions, startlanes = [], []

        # generate uniform starting positions
        while car_count < num_vehicles:
            # collect the position and lane number of each new vehicle
            pos = self.get_edge(x)

            # ensures that vehicles are not placed in an internal junction
            while pos[0] in dict(self.internal_edgestarts).keys():
                # find the location of the internal edge in total_edgestarts,
                # which has the edges ordered by position
                edges = [tup[0] for tup in self.total_edgestarts]
                indx_edge = next(
                    i for i, edge in enumerate(edges) if edge == pos[0])

                # take the next edge in the list, and place the car at the
                # beginning of this edge
                if indx_edge == len(edges) - 1:
                    next_edge_pos = self.total_edgestarts[0]
                else:
                    next_edge_pos = self.total_edgestarts[indx_edge + 1]

                x = next_edge_pos[1]
                pos = (next_edge_pos[0], 0)

            # ensures that you are in an acceptable edge
            while pos[0] not in available_edges:
                x = (x + self.edge_length(pos[0])) % self.non_internal_length()
                pos = self.get_edge(x)

            # ensure that in variable lane settings vehicles always start a
            # vehicle's length away from the start of the edge. This, however,
            # prevents the spacing to be completely uniform.
            if flag and pos[1] < VEHICLE_LENGTH:
                pos0, pos1 = pos
                pos = (pos0, VEHICLE_LENGTH)
                x += VEHICLE_LENGTH
                increment -= (VEHICLE_LENGTH * self.num_lanes(pos0)) / \
                             (num_vehicles - car_count)

            # place vehicles side-by-side in all available lanes on this edge
            for lane in range(min([self.num_lanes(pos[0]), lanes_distr])):
                car_count += 1
                startpositions.append(pos)
                startlanes.append(lane)

                if car_count == num_vehicles:
                    break

            x = (x + increment + VEHICLE_LENGTH + min_gap) % self.non_internal_length()

        # add a perturbation to each vehicle, while not letting the vehicle
        # leave its current edge
        if initial_config.perturbation > 0:
            for i in range(num_vehicles):
                perturb = np.random.normal(0, initial_config.perturbation)
                edge, pos = startpositions[i]
                pos = max(0, min(self.edge_length(edge), pos + perturb))
                startpositions[i] = (edge, pos)

        return startpositions, startlanes

    def gen_random_start_pos(self, initial_config, num_vehicles):
        """Generate random starting positions.

        Parameters
        ----------
        initial_config : ilurl.flow.params.InitialConfig
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network

        Returns
        -------
        list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        list of int
            list of start lanes
        """
        if isinstance(initial_config.edges_distribution, dict):
            # check that the number of vehicle in edges_distribution matches
            # that of the vehicles class
            num_vehicles_e = sum(initial_config.edges_distribution[k]
                                 for k in initial_config.edges_distribution)
            assert num_vehicles == num_vehicles_e, \
                'Number of vehicles in edges_distribution and the Vehicles ' \
                'class do not match: {}, {}'.format(num_vehicles,
                                                    num_vehicles_e)

            # add starting positions and lanes
            edges_distribution = deepcopy(initial_config.edges_distribution)
            startpositions, startlanes = [], []
            for key in edges_distribution:
                # set the edge distribution to only include the next edge
                initial_config.edges_distribution = [key]
                # set the number of vehicles that this edge can carry
                num_vehicles = edges_distribution[key]
                # recursively collect the next starting positions and lanes
                pos, lane = self.gen_random_start_pos(
                    initial_config, num_vehicles)
                startpositions.extend(pos)
                startlanes.extend(lane)
            return startpositions, startlanes

        (x0, min_gap, bunching, lanes_distr, available_length,
         available_edges, initial_config) = self._get_start_pos_util(
            initial_config, num_vehicles)

        # extra space a vehicle needs to cover from the start of an edge to be
        # fully in the edge and not risk having a gap with a vehicle behind it
        # that is smaller than min_gap
        efs = min_gap + VEHICLE_LENGTH  # extra front space

        for edge in available_edges:
            available_length -= efs * min([self.num_lanes(edge), lanes_distr])

        # choose random positions for each vehicle
        init_absolute_pos = [random.random() * available_length
                             for _ in range(num_vehicles)]
        init_absolute_pos.sort()

        # these positions do not include the length of the vehicle, which need
        # to be added
        for i in range(num_vehicles):
            init_absolute_pos[i] += (VEHICLE_LENGTH + min_gap) * i

        decrement = 0
        edge_indx = 0
        startpositions = []
        startlanes = []
        for i in range(num_vehicles):
            edge_i = available_edges[edge_indx]
            pos_i = (init_absolute_pos[i] - decrement) % (
                    self.edge_length(edge_i) - efs)
            lane_i = int(((init_absolute_pos[i] - decrement) - pos_i) /
                         (self.edge_length(edge_i) - efs))

            pos_i += efs

            while lane_i > min([self.num_lanes(edge_i), lanes_distr]) - 1:
                decrement += min([self.num_lanes(edge_i), lanes_distr]) \
                             * (self.edge_length(edge_i) - efs)
                edge_indx += 1

                edge_i = available_edges[edge_indx]
                pos_i = (init_absolute_pos[i] - decrement) % (
                        self.edge_length(edge_i) - efs)

                lane_i = int(((init_absolute_pos[i] - decrement) - pos_i) /
                             (self.edge_length(edge_i) - efs))

                pos_i += efs

            startpositions.append((edge_i, pos_i))
            startlanes.append(lane_i)

        return startpositions, startlanes

    def gen_custom_start_pos(self, initial_config, num_vehicles):
        """Generate a user defined set of starting positions.

        This is called straight from the network class.

        Parameters
        ----------
        initial_config : ilurl.flow.params.InitialConfig
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network

        Returns
        -------
        list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        list of int
            list of start lanes
        """
        return self.network.gen_custom_start_pos(
            cls=self,
            net_params=self.network.net_params,
            initial_config=initial_config,
            num_vehicles=num_vehicles,
        )

    def _get_start_pos_util(self, initial_config, num_vehicles):
        """Prepare initial_config data for starting position methods.

        Performs some pre-processing to the initial_config and **kwargs terms,
        and returns the necessary values for all starting position generating
        functions.

        Parameters
        ----------
        initial_config : InitialConfig type
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network

        Returns
        -------
        x0 : float
            starting position of the first vehicle, in meters
        min_gap : float
            minimum gap between vehicles
        bunching : float
            the amount of space freed up in the network (per lane)
        lanes_distribution : int
            number of lanes the vehicles are supposed to be distributed over
        available_length : float
            total available free space for vehicle to be placed, over all lanes
            within the distributable lanes, in meters
        initial_config : InitialConfig type
            modified version of the initial_config parameter

        Raises
        ------
        ValueError
            If there is not enough space to place all vehicles in the allocated
            space in the network with the specified minimum gap.
        """
        min_gap = max(0, initial_config.min_gap)

        bunching = initial_config.bunching
        # check if requested bunching value is not valid (negative)
        if initial_config.bunching < 0:
            logging.warning('"bunching" cannot be negative; setting to 0')
            initial_config.bunching = 0

        # compute the lanes distribution (adjust of edge cases)
        if initial_config.edges_distribution == 'all':
            max_lane = max(
                [self.num_lanes(edge_id) for edge_id in self.get_edge_list()])
        else:
            max_lane = max([
                self.num_lanes(edge_id)
                for edge_id in initial_config.edges_distribution
            ])

        if initial_config.lanes_distribution > max_lane:
            lanes_distribution = max_lane
        elif initial_config.lanes_distribution < 1:
            logging.warning('"lanes_distribution" is too small; setting to 1')
            lanes_distribution = 1
        else:
            lanes_distribution = initial_config.lanes_distribution

        if initial_config.edges_distribution == 'all':
            distribution_length = \
                sum(self.edge_length(edge_id) *
                    min([self.num_lanes(edge_id), lanes_distribution])
                    for edge_id in self.get_edge_list()
                    if self.edge_length(edge_id) > min_gap + VEHICLE_LENGTH)
        else:
            distribution_length = \
                sum(self.edge_length(edge_id) *
                    min(self.num_lanes(edge_id), lanes_distribution)
                    for edge_id in initial_config.edges_distribution
                    if self.edge_length(edge_id) > min_gap + VEHICLE_LENGTH)

        if initial_config.edges_distribution == 'all':
            available_edges = [
                edge for edge in self.get_edge_list()
                if self.edge_length(edge) > min_gap + VEHICLE_LENGTH]
        else:
            available_edges = [
                edge for edge in initial_config.edges_distribution
                if self.edge_length(edge) > min_gap + VEHICLE_LENGTH]

        available_length = \
            distribution_length - lanes_distribution * bunching - \
            num_vehicles * (min_gap + VEHICLE_LENGTH)

        if available_length < 0:
            raise ValueError('There is not enough space to place all '
                                 'vehicles in the network.')

        return (initial_config.x0, min_gap, bunching, lanes_distribution,
                available_length, available_edges, initial_config)

"""Script containg the CITYFLOW kernel class."""
# TODO: Remove traCI dependencies
import json

from ilurl.flow.network_kernel import BaseKernelNetwork
import os
from copy import deepcopy

# Number of retries on accessing the .net.xml file before giving up
RETRIES_ON_ERROR = 10
# number of seconds to wait before trying to access the .net.xml file again
WAIT_ON_ERROR = 1

class CityflowKernelNetwork(BaseKernelNetwork):
    """Base network kernel for sumo-based simulations.

    This class initializes a new network. Networks are used to specify
    features of a network, including the positions of nodes, properties of the
    edges and junctions connecting these nodes, properties of vehicles and
    traffic lights, and other features as well.
    """

    def __init__(self, master_kernel, sim_params):
        """Instantiate a sumo network kernel.

        Parameters
        ----------
        master_kernel : flow.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        sim_params : ilurl.flow.params.SimParams
            simulation-specific parameters
        """
        super(CityflowKernelNetwork, self).__init__(master_kernel, sim_params)

        self.network = None
        target_path = sim_params.emission_path

        # TODO: integrate simulation tools to convert flows.
        # Or pre-define flows.
        self.cfg_path = None
        self.roadnet_path = None
        self.flow_path = None
        if target_path is not None:
            target_dir = Path(target_path) / 'config'
            target_dir.mkdir(parents=True, exist_ok=True)
            self.cfg_path = target_dir / 'config.json'
            self.roadnet_path = target_dir / 'roadnet.json'
            self.flow_path = target_dir / 'flow.json'

        self._edges = None
        self._connections = None
        self._edge_list = None
        self._junction_list = None
        # self.__max_speed = None
        # self.__length = None  # total length
        # self.__non_internal_length = None  # total length of non-internal edges
        self.rts = None

        self.cfg = None
        self.roadnet = None
        self.flow = None

    # TODO: Remove
    def close(self):
        """Close the network class.

        Deletes the xml files that were created by the network class. This
        is to prevent them from building up in the debug folder. Note that in
        the case of import .net.xml files we do not want to delete them.
        """
        pass


    def update(self, reset):
        """Perform no action of value (networks are static)."""
        pass

    def edge_length(self, edge_id):
        """See parent class."""
        try:
            return self._edges[edge_id]['length']
        except KeyError:
            print('Error in edge length with key', edge_id)
            return -1001

    def generate_cfg(self, net_params, traffic_lights, routes):
        """Generate .sumo.cfg files using net files and netconvert.

        This method is responsible for creating the following config files:

        - *.rou.xml: This file contains the routes vehicles can traverse,
          either from a specific starting edge, or by vehicle name, and well as
          the inflows of vehicles.
        - *.gui.cfg: This file contains the view settings of the gui (whether
          the gui is used or not). The background of the gui is set here to be
          grey, with RGB values: (100, 100, 100).
        - *.sumo.cfg: This is the file that is used by the simulator to
          identify the location of the various network, vehicle, and traffic
          light properties that are used when instantiating the simulation.

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py
        traffic_lights : ilurl.flow.params.TrafficLightParams
            traffic light information, used to determine which nodes are
            treated as traffic lights
        routes : dict
            Key = name of the starting edge
            Element = list of edges a vehicle starting from this edge must
            traverse.
        """

        # cfg_path is None than use defaults.
        source_path = NETWORKS_PATH / self.orig_name
        if self.cfg_path is None:
            path_parts = [pp for pp in source_path.parts if pp not in ILURL_PATH.parts]
            rel_dir = '/'.join(path_parts)

            self.cfg_path = source_path / 'config.json'
            self.cfg_rel_path = Path(rel_dir) / 'config.json'

        # TODO: Breakdown all those functions into
        # gen_net, gen_flow, gen_cfg
        if self.cfg_path != (source_path / 'config.json') or self.flow is None:
            # II. Process flow
            # II.1 translate attributes
            vehicles = self.network.vehicles
            assert len(vehicles.types) == 1 and vehicles.types[0]['veh_id'] == 'human'
            oldvehicle =  vehicles.types[0]['type_params']
            vehicle = {'length':  5, 'width': 2, 'headwayTime': 1.5}
            transl = [
                ('maxPosAcc','accel'), ('maxNegAcc', 'decel'),
                ('usualPosAcc','accel'), ('usualNegAcc','decel'),
                ('minGap', 'min_gap'), ('maxSpeed', 'max_speed')
            ]
            for _to, _from in transl:
                vehicle[_to] = oldvehicle[_from]


            # II.2. FLOW
            flows = []
            inflows = net_params.inflows.__dict__['_InFlows__flows']
            for inflow in inflows:
                for edges, perc in routes[inflow['edge']]:
                    # Converts insertion probability on emission interval
                    flows.append({
                        'vehicle': vehicle,
                        'route': edges,
                        'interval': round(1 / (inflow['probability'] * perc)),
                        'startTime':inflow['begin'],
                        'endTime':inflow['end'],
                    })
            self.flow = flows
            # Creates a default flow file.
            if not (source_path / 'flow.json').exists():
                with (source_path / 'flow.json').open('w') as f: json.dump(self.flow, f)

            # gets the relative path
            path_parts = [pp for pp in self.cfg_path.parent.parts if pp not in ILURL_PATH.parts]
            rel_dir = '/'.join(path_parts)
            rel_dir += '/'      # dir variable must end with '/'
            self.cfg_rel_path = Path(rel_dir) / 'config.json'
            self.cfg['dir'] = rel_dir
            # III. Dump if necessary
            # TODO: include replay
            with (self.cfg_path).open('w') as f: json.dump(self.cfg, f)
            with (self.flow_path).open('w') as f: json.dump(self.flow, f)
            with (self.roadnet_path).open('w') as f: json.dump(self.roadnet, f)

        return self.cfg_path

    def generate_net_from_template(self, net_params):
        """Pass relevant data from an already processed .net.xml file.

        This method is used to collect the edges and connection data from a
        network template file and pass it to the network class for later use.

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            network-specific parameters. Different networks require different
            net_params; see the separate sub-classes for more information.

        Returns
        -------
        edges : dict <dict>
            Key = name of the edge
            Elements = length, lanes, speed
        connection_data : dict < dict < list < (edge, pos) > > >
            Key = name of the arriving edge
                Key = lane index
                Element = list of edge/lane pairs that a vehicle can traverse
                from the arriving edge/lane pairs
        """
        # name of the .net.xml file (located in cfg_path)
        if type(net_params.template) is str:
            net_path = net_params.template
        else:
            net_path = net_params.template['net']

        # collect data from the generated network configuration file
        edges_dict, conn_dict = self._import_edges_from_net(net_params, net_path)

        return edges_dict, conn_dict

    def generate_network(self, network):
        """See parent class.

        This class uses network specific features to generate the necessary xml
        files needed to initialize a sumo instance. This includes a .net.xml
        file for network geometry

        Parameters
        ----------
        network : flow.networks.Network
            an object containing relevant network-specific features such as the
            locations and properties of nodes and edges in the network
        """
        # store the network object in the network variable
        self.network = network
        self.orig_name = network.orig_name
        self.name = network.name


        # instanciate the roadnets, flows and config.
        source_path = Path(NETWORKS_PATH) / self.orig_name
        with (source_path / 'config.json').open() as f: self.cfg = json.load(f)
        with (source_path / 'roadnet.json').open() as f: self.roadnet = json.load(f)
        if (source_path / 'flow.json').exists():
            with (source_path / 'flow.json').open() as f: self.flow = json.load(f)

        # can only provide one of osm path or template path to the network
        assert self.network.net_params.template is None \
            or self.network.net_params.osm_path is None

        # create the network configuration files
        if self.network.net_params.template is not None:
            self._edges, self._connections = self.generate_net_from_template(
                self.network.net_params
            )
        else:
            raise ValueError(f'Network template must be provided')
        # elif self.network.net_params.osm_path is not None:
        #     self._edges, self._connections = self.generate_net_from_osm(
        #         self.network.net_params)
        # else:
        #     # combine all connections into a list
        #     if network.connections is not None:
        #         if isinstance(network.connections, list):
        #             connections = network.connections
        #         else:
        #             connections = []
        #             for key in network.connections.keys():
        #                 connections.extend(network.connections[key])
        #     else:
        #         connections = None

        #     self._edges, self._connections = self.generate_net(
        #         self.network.net_params,
        #         self.network.traffic_lights,
        #         self.network.nodes,
        #         self.network.edges,
        #         self.network.types,
        #         connections
        #     )

        # list of edges and internal links (junctions)
        self._edge_list = [
            edge_id for edge_id in self._edges.keys() if edge_id[0] != ':'
        ]
        self._junction_list = list(
            set(self._edges.keys()) - set(self._edge_list))

        # maximum achievable speed on any edge in the network
        self.__max_speed = max(
            self.speed_limit(edge) for edge in self.get_edge_list())

        # length of the network, or the portion of the network in
        # which cars are meant to be distributed
        self.__non_internal_length = sum(
            self.edge_length(edge_id) for edge_id in self.get_edge_list()
        )

        # parameters to be specified under each unique subclass's
        # __init__ function
        self.edgestarts = self.network.edge_starts

        # if no edge_starts are specified, generate default values to be used
        # by the "get_x" method
        if self.edgestarts is None:
            length = 0
            self.edgestarts = []
            for edge_id in sorted(self._edge_list):
                # the current edge starts where the last edge ended
                self.edgestarts.append((edge_id, length))
                # increment the total length of the network with the length of
                # the current edge
                length += self._edges[edge_id]['length']

        # these optional parameters need only be used if "no-internal-links"
        # is set to "false" while calling sumo's netconvert function
        self.internal_edgestarts = self.network.internal_edge_starts
        self.internal_edgestarts_dict = dict(self.internal_edgestarts)

        # total_edgestarts and total_edgestarts_dict contain all of the above
        # edges, with the former being ordered by position
        self.total_edgestarts = self.edgestarts + self.internal_edgestarts
        self.total_edgestarts.sort(key=lambda tup: tup[1])

        self.total_edgestarts_dict = dict(self.total_edgestarts)

        self.__length = sum(
            self._edges[edge_id]['length'] for edge_id in self._edges
        )

        if self.network.routes is None:
            print("No routes specified, defaulting to single edge routes.")
            self.network.routes = {edge: [edge] for edge in self._edge_list}

        # specify routes vehicles can take  # TODO: move into a method
        self.rts = self.network.routes

        # create the cityflow configuration files
        # TODO: invert generate_cfg with generate_net_from_template
        self.generate_cfg(self.network.net_params,
                          self.network.traffic_lights,
                          self.network.routes)

    def max_speed(self):
        return self.__max_speed

    def get_edge_list(self):
        """See parent class."""
        return self._edge_list

    def get_junction_list(self):
        """See parent class."""
        return self._junction_list

    def _import_edges_from_net(self, net_params, net_path):
        """Import edges from a configuration file.

        This is a utility function for computing edge information. It imports a
        network configuration file, and returns the information on the edges
        and junctions located in the file.

        Parameters
        ----------
        net_params : ilurl.flow.params.NetParams
            see flow/core/params.py

        Returns
        -------
        net_data : dict <dict>
            Key = name of the edge/junction
            Element = lanes, speed, length
        connection_data : dict < dict < list < (edge, pos) > > >
            Key = "prev" or "next", indicating coming from or to this
            edge/lane pair
                Key = name of the edge
                    Key = lane index
                    Element = list of edge/lane pairs preceding or following
                    the edge/lane pairs
        """
        def road_to_dict(road_dict):
            # number of lanes
            lanes = len(road_dict['lanes'])
            # lane with maximum speed (usually is an edge feature)
            speed = max(road_dict['lanes'], key=lambda x: x['maxSpeed'])
            # start and finishing points
            p1, p2 = road_dict['points']
            # Euclidean distance
            dist = np.sqrt((p1['x'] - p2['x'])**2 + (p1['y'] - p2['y'])**2)
            return {'lanes': lanes,
                    'speed': speed['maxSpeed'],
                    'length': np.round(dist, 2)}
        net_data = {
            rd['id']: road_to_dict(rd)
            for rd in self.roadnet['roads']
        }

        
        intersections = [itr for itr in self.roadnet['intersections'] if not itr['virtual']]
        next_link_data = defaultdict(lambda : defaultdict(lambda : []))
        prev_link_data = defaultdict(lambda : defaultdict(lambda : []))
        for itr in intersections: 
          for road_link in itr['roadLinks']:
                from_road = road_link['startRoad']  
                to_road = road_link['endRoad']  
                for lane_link in road_link['laneLinks']:
                    from_lane = lane_link['startLaneIndex']  
                    to_lane = lane_link['endLaneIndex']  
                    next_link_data[from_road][from_lane].append((to_road, to_lane))
                    prev_link_data[to_road][to_lane].append((from_road, from_lane))

        connection_data = {'next': next_link_data, 'prev': prev_link_data}

        # # collect connection data
        # for connection in root.findall('connection'):
        #     from_edge = connection.attrib['from']
        #     from_lane = int(connection.attrib['fromLane'])

        #     if from_edge[0] != ":":
        #         # if the edge is not an internal link, then get the next
        #         # edge/lane pair from the "via" element
        #         via = connection.attrib['via'].rsplit('_', 1)
        #         to_edge = via[0]
        #         to_lane = int(via[1])
        #     else:
        #         to_edge = connection.attrib['to']
        #         to_lane = int(connection.attrib['toLane'])

        #     if from_edge not in next_conn_data:
        #         next_conn_data[from_edge] = dict()

        #     if from_lane not in next_conn_data[from_edge]:
        #         next_conn_data[from_edge][from_lane] = list()

        #     if to_edge not in prev_conn_data:
        #         prev_conn_data[to_edge] = dict()

        #     if to_lane not in prev_conn_data[to_edge]:
        #         prev_conn_data[to_edge][to_lane] = list()

        #     next_conn_data[from_edge][from_lane].append((to_edge, to_lane))
        #     prev_conn_data[to_edge][to_lane].append((from_edge, from_lane))

        # connection_data = {'next': next_conn_data, 'prev': prev_conn_data}
        # TODO: connections
        # # import the .net.xml file containing all edge/type data
        # parser = etree.XMLParser(recover=True)
        # # net_path = os.path.join(self.cfg_path, self.roadnet) \
        # #     if net_params.template is None else self.roadnet
        # tree = ElementTree.parse(net_path, parser=parser)
        # root = tree.getroot()

        # # Collect information on the available types (if any are available).
        # # This may be used when specifying some edge data.
        # types_data = dict()

        # for typ in root.findall('type'):
        #     type_id = typ.attrib['id']
        #     types_data[type_id] = dict()

        #     if 'speed' in typ.attrib:
        #         types_data[type_id]['speed'] = float(typ.attrib['speed'])
        #     else:
        #         types_data[type_id]['speed'] = None

        #     if 'numLanes' in typ.attrib:
        #         types_data[type_id]['numLanes'] = int(typ.attrib['numLanes'])
        #     else:
        #         types_data[type_id]['numLanes'] = None

        # net_data = dict()
        # next_conn_data = dict()  # forward looking connections
        # prev_conn_data = dict()  # backward looking connections

        # # collect all information on the edges and junctions
        # for edge in root.findall('edge'):
        #     edge_id = edge.attrib['id']

        #     # create a new key for this edge
        #     net_data[edge_id] = dict()

        #     # check for speed
        #     if 'speed' in edge:
        #         net_data[edge_id]['speed'] = float(edge.attrib['speed'])
        #     else:
        #         net_data[edge_id]['speed'] = None

        #     # if the edge has a type parameters, check that type for a
        #     # speed and parameter if one was not already found
        #     if 'type' in edge.attrib and edge.attrib['type'] in types_data:
        #         if net_data[edge_id]['speed'] is None:
        #             net_data[edge_id]['speed'] = \
        #                 float(types_data[edge.attrib['type']]['speed'])

        #     # collect the length from the lane sub-element in the edge, the
        #     # number of lanes from the number of lane elements, and if needed,
        #     # also collect the speed value (assuming it is there)
        #     net_data[edge_id]['lanes'] = 0
        #     for i, lane in enumerate(edge):
        #         net_data[edge_id]['lanes'] += 1
        #         if i == 0:
        #             net_data[edge_id]['length'] = float(lane.attrib['length'])
        #             if net_data[edge_id]['speed'] is None \
        #                     and 'speed' in lane.attrib:
        #                 net_data[edge_id]['speed'] = float(
        #                     lane.attrib['speed'])

        #     # if no speed value is present anywhere, set it to some default
        #     if net_data[edge_id]['speed'] is None:
        #         net_data[edge_id]['speed'] = 30

        # # collect connection data
        # for connection in root.findall('connection'):
        #     from_edge = connection.attrib['from']
        #     from_lane = int(connection.attrib['fromLane'])

        #     if from_edge[0] != ":":
        #         # if the edge is not an internal link, then get the next
        #         # edge/lane pair from the "via" element
        #         via = connection.attrib['via'].rsplit('_', 1)
        #         to_edge = via[0]
        #         to_lane = int(via[1])
        #     else:
        #         to_edge = connection.attrib['to']
        #         to_lane = int(connection.attrib['toLane'])

        #     if from_edge not in next_conn_data:
        #         next_conn_data[from_edge] = dict()

        #     if from_lane not in next_conn_data[from_edge]:
        #         next_conn_data[from_edge][from_lane] = list()

        #     if to_edge not in prev_conn_data:
        #         prev_conn_data[to_edge] = dict()

        #     if to_lane not in prev_conn_data[to_edge]:
        #         prev_conn_data[to_edge][to_lane] = list()

        #     next_conn_data[from_edge][from_lane].append((to_edge, to_lane))
        #     prev_conn_data[to_edge][to_lane].append((from_edge, from_lane))

        # connection_data = {'next': next_conn_data, 'prev': prev_conn_data}

        return net_data, connection_data

    def num_lanes(self, edge_id):
        """See parent class."""
        try:
            return self._edges[edge_id]['lanes']
        except KeyError:
            print('Error in num lanes with key', edge_id)
            return -1001

    def speed_limit(self, edge_id):
        """See parent class."""
        try:
            return self._edges[edge_id]['speed']
        except KeyError:
            print('Error in speed limit with key', edge_id)
            return -1001


