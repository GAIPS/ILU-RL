"""Script containing the base traffic light kernel class."""


class KernelTrafficLight(object):
    """Base traffic light kernel.

    This kernel sub-class is used to interact with the simulator with regards
    to all traffic light -dependent components. Specifically, this class
    contains methods for:

    * Interacting with the simulator: This consisting specifying the states of
      certain traffic lights at a given time step. This can be done by calling
      the following method:

        >>> from ilurl.flow.envs.base import Env
        >>> env = Env(...)
        >>> node_id = 'test_intersection'  # name of the node
        >>> env.k.traffic_light.set_state(node_id, 'r')

    * State acquisition: This methods contains several methods for acquiring
      state information from specific traffic lights. For example, if you would
      like to get the state ("r", "g", etc.) of a node with a traffic light,
      that can be done by calling:

        >>> tl_state = env.k.traffic_light.get_state(node_id)

    All methods in this class are abstract, and must be filled in by the child
    vehicle kernel of separate simulators.
    """

    def __init__(self, master_kernel):
        """Instantiate the base traffic light kernel.

        Parameters
        ----------
        master_kernel : flow.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        """
        self.master_kernel = master_kernel
        self.kernel_api = None

    def pass_api(self, kernel_api):
        """Acquire the kernel api that was generated by the simulation kernel.

        Parameters
        ----------
        kernel_api : any
            an API that may be used to interact with the simulator
        """
        self.kernel_api = kernel_api

    def update(self, reset):
        """Update the states and phases of the traffic lights.

        This ensures that the traffic light variables match current traffic
        light data.

        Parameters
        ----------
        reset : bool
            specifies whether the simulator was reset in the last simulation
            step
        """
        raise NotImplementedError

    def get_ids(self):
        """Return the names of all nodes with traffic lights."""
        raise NotImplementedError

    def set_state(self, node_id, state, link_index="all"):
        """Set the state of the traffic lights on a specific node.

        Parameters
        ----------
        node_id : str
            name of the node with the controlled traffic lights
        state : str
            desired state(s) for the traffic light
        link_index : int, optional
            index of the link whose traffic light state is meant to be changed.
            If no value is provided, the lights on all links are updated.
        """
        raise NotImplementedError

    def get_state(self, node_id):
        """Return the state of the traffic light(s) at the specified node.

        Parameters
        ----------
        node_id: str
            name of the node

        Returns
        -------
        state : str
            Index = lane index
            Element = state of the traffic light at that node/lane
        """
        raise NotImplementedError
"""Script containing the Cityflow traffic light kernel class."""
import json
from pathlib import Path

from cityflow import Engine

from ilurl.flow.traffic_light_kernel import KernelTrafficLight
# import traci.constants as tc # TODO: REMOVE

class CityflowTrafficLight(KernelTrafficLight):
    """Cityflow traffic light kernel.

    Implements all methods discussed in the base traffic light kernel class.
    """

    def __init__(self, master_kernel):
        """Instantiate the sumo traffic light kernel.

        Parameters
        ----------
        master_kernel : flow.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        """
        super(CityflowTrafficLight, self).__init__(master_kernel)
        self.__tls = dict()  # contains current time step traffic light data
        self.__tls_properties = dict()  # traffic light xml properties

        # names of nodes with traffic lights
        self.__ids = []

        # number of traffic light nodes
        self.num_traffic_lights = 0

    def pass_api(self, kernel_api, network_kernel):
        """See parent class.

        Subscriptions and vehicle IDs are also added here.

        cityflow's engine doesn't allow for querying "static" data
        "static" data -- data that can be looked up on file
        """
        super(CityflowTrafficLight, self).pass_api(kernel_api)

        # names of nodes with traffic lights
        # self.__ids = kernel_api.trafficlight.getIDList()
        # road_path = Path(network_kernel.roadnet_path) / network_kernel.roadnet
        # with road_path.open() as f: roadnet = json.load(f)
        roadnet = network_kernel.roadnet

        self.__ids = [it['id'] for it in roadnet['intersections'] if not it['virtual']]
        # number of traffic light nodes
        self.num_traffic_lights = len(self.__ids)

        # subscribe the traffic light signal data
        # for node_id in self.__ids:
        #     self.kernel_api.trafficlight.subscribe(
        #         node_id, [tc.TL_RED_YELLOW_GREEN_STATE])
        # TODO: find a way to map 
        tls_properties = network_kernel.network.traffic_lights.get_properties()
        self.__sumo_to_cityflow = {}
        for node_id in self.__ids:
            phases = tls_properties[node_id]['phases']
            self.__sumo_to_cityflow[node_id] = {p['state']: i for i, p in enumerate(phases)}

    def update(self, reset):
        """See parent class."""
        pass
        # set_trace()
        # tls_obs = {}
        # for tl_id in self.__ids:
        #     tls_obs[tl_id] = \
        #         self.kernel_api.trafficlight.getSubscriptionResults(tl_id)
        # self.__tls = tls_obs.copy()

    def get_ids(self):
        """See parent class."""
        return self.__ids

    def set_state(self, node_id, state, link_index="all"):
        """See parent class."""
        if link_index == "all":
            # if lights on all lanes are changed
            # self.kernel_api.trafficlight.setRedYellowGreenState(
            #     tlsID=node_id, state=state)
            phase_id = self.__sumo_to_cityflow[node_id][state]
            self.kernel_api.set_tl_phase(node_id, phase_id)
        else:
            raise ValueError('link_index must be equal to "all"')
            # if lights on a single lane is changed
            # self.kernel_api.trafficlight.setLinkState(
            #     tlsID=node_id, tlsLinkIndex=link_index, state=state)

    def get_state(self, node_id):
        """See parent class."""
        set_trace()
        return self.__tls[node_id][tc.TL_RED_YELLOW_GREEN_STATE]
